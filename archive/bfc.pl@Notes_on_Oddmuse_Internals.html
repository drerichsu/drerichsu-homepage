<head><link type="text/css" rel="stylesheet" href="https://drerichsu.github.io/drerichsu-homepage/assets/css/style.css" /></head>
<h1><a title="Click to search for references to this page" href="bfc.pl@search=%2522Notes+on+Oddmuse+Internals%2522.html" rel="nofollow">Notes on Oddmuse Internals</a><span class="cart-checkbox" style="float:right">	<input type="checkbox" value="cart" id="Notes_on_Oddmuse_Internals-set" title="Add To Cart" /> <br>
</span></h1></div><div class="wrapper"><div class="content browse"><p>I’ve been hacking on and around the innards of Oddmuse, so I wanted to pause and record some notes, as it is fairly undocumented.</p><p><div class="toc"><h2>Contents</h2><ol><li><a href="bfc.pl@Notes_on_Oddmuse_Internals.html#Heading1">How Does It Work?</a><ol><li><a href="bfc.pl@Notes_on_Oddmuse_Internals.html#Heading2">Initalize and Parse Action</a></li><li><a href="bfc.pl@Notes_on_Oddmuse_Internals.html#Heading3">Search and Replace</a></li><li><a href="bfc.pl@Notes_on_Oddmuse_Internals.html#Heading4">How Formatting Works</a></li><li><a href="bfc.pl@Notes_on_Oddmuse_Internals.html#Heading5">Localization</a></li><li><a href="bfc.pl@Notes_on_Oddmuse_Internals.html#Heading6">Cookies</a></li></ol></li></ol></div><h2 id="Heading1">How Does It Work?</h2> Roughly speaking, the program flow is like this.</p><p><h3 id="Heading2">Initalize and Parse Action</h3><ul><li>Initialize a bunch of global variables with straight declarations, then go to DoWikiRequest, which is the main program.</li><li>Init()<ul><li>create directories, initialize some link globals</li><li>load modules<ul><li>it uses <code>glob</code>, so I think they are loaded in your system’s alphanumeric order.</li></ul></li><li>load config<ul><li>Note this comes after modules, so you can configure variables in modules in your config file.</li></ul></li><li>InitRequest(). This creates $q, which is a standard CGI.pm object.<ul><li>Notice this means your modules will NOT have access to $q in their global variable declarations, but will have it when the actual subs run.</li></ul></li><li>use $q method to get the cookie <code>$CookieName</code> and put it in <code>%NewCookie</code></li><li>InitVariables() clears out globals in case you’re using mod_perl.</li></ul></li><li>DoSurgeProtection()</li><li>It does some simple user permissions checks.<ul><li>Note for the record there are UserIsEditor(), UserIsAdmin(), UserIsBanned(), UserCanEdit(), as well as UserIsEditorOrError and UserIsAdminOrError.</li></ul></li><li>Now we’re in DoBrowseRequest(),<ul><li>This figures out the <code>action</code> from the CGI params and decides if this is a Search, Post, Download or a Page to Resolve.</li><li>Note the use of GetId() which figures out the current page name. Quite often <code>$q-&gt;param(id)</code> doesn’t exist, so this needs to do some thinking. For instance, typically pages are called as <code>script/pagename</code> or <code>script?pagename, </code>or no pagename defaults the id to<code> $HomePage. </code></li></ul></li></ul> <h3 id="Heading3">Search and Replace</h3><ul><li>DoSearch covers Indexing, Replace and Search. DoIndex and Replace handle the obvious things.</li><li>Most of search part of DoSearch is spent setting up the search page with title.</li><li>SearchTitleAndBody is where the actual searching happens.<ul><li>You pass it a \&amp;PrintSearchResult routine to report found pages and @args to pass to &amp;PrintSearchResult.</li><li>The built-in search is quite brute force. We loop over every page returned by AllPagesList() (which itself just looks in your <code>pageidx</code>). For each page, we run<code> SearchString($regexp, $data)</code>, which applies splits $regexp into space-delimited regexps and runs each one as a perl search on $data. This is an AND search, as success is reported only if they all match. Searches are /$regexp/i, that is, case-insensitive.</li><li>OPTIMIZATION Idea.<ul><li>Currently, for each page we apply each piece of the $regexp. That means each of the R regexp pieces gets recompiled for each of the P pages. That’s R*P recompilations. If we use some of the ideas from <a class="url http outside" href="http://www.stonehenge.com/merlyn/UnixReview/col28.html">Schwartz</a> (namely use $compiled = qr/$regexppiece/, â¦ $data=/$compiled/), and rework the loop, we should get a nice savings. The loop could be reworked so that we loop over each piece of the regexp. $string also gets scanned for null entries once for each page!! Compile the pattern at the start of the loop. Now loop over all the pages, tracking success in a hash somewhere, and abandoning the check if we’re successful. We can sort results if necessary.</li><li>OR We can keep the logic of the page if we insert at the start of SearchTitleAndBody a compilation of each regexp piece, and instead of passing $string, pass @compiled_searches.<ul><li>I actually tried this on a site with about 1880 pages with queries with 4 parts (natural) and 15ish parts (contrived). The unoptimized searches never took more than 0.5 sec. Optimized searches did take slightly less time, but about 5-10% faster. Not worth the trouble.</li></ul></li></ul></li></ul></li></ul> <h3 id="Heading4">How Formatting Works</h3><ul><li>It all happens in ApplyRules, which more or less starts with the raw markup in $text. After we branch off for pages with uploaded file content, we do a big infinite <code>while(1)</code> loop.</li><li>In this master loop, a number of short routines take turns trying to match the beginning of $text (now in <code>local $_</code>).</li><li>After a number of hardcoded routines take their turn (and these should probably be refactored out as Rules, like LinkRules, etc.), then the modules can have their routines run as MyRules.</li><li>Once there is a match, the loop begins again but with routines trying to match the beginning of the unmatched part of $text. This is implemented through the required \G match starting each regexp.<ul><li>Note each search is of the form <code>m/\G regexp/cg;</code> This is important, because module formatting rules need to have this form as well, or they will mess up processing of other rules. The special parts of the search are:</li><li>The \G matches where the last successful search ended. This means that once a Rule matches some markup, no other Rule can match it. So if you are competing with existing markup rules, you need to set <code>$RuleOrder{\&amp;YourSub}</code> to some number, either very positive to assure firing late, or very negative to assure firing early.</li><li>The cg flags mean that if we *don’t *match, then we will reset our search start to where the search began.</li></ul></li><li>In principle one might worry there won’t be a match and large hunks of the markup won’t get processed and output. In reality, the last searches are for strings of plaintext words separated by non-linebreak whitespace.</li></ul> <h3 id="Heading5">Localization</h3><ul><li>T, Ts, Tss are all routines one should call on output text strings to allow future modules to translate them.</li></ul> <h3 id="Heading6">Cookies</h3><ul><li>Using $q methods, the cookie <code>$CookieName</code> gets put in <code>%NewCookie</code> during <code>Init().</code></li><li>SetParam and GetParam are the official ways to access the site cookie values. SetParam just updates %NewCookie. The values of the cookie get flushed to header when GetHttpHeader is called. Remember to set $InvisibleCookieParameters{$key}to avoid lots of annoying status change messages, and%CookieParameters if you want the key/value to persist in the cookie.</li></ul></p></div><div class="wrapper close"></div></div><div class="footer">